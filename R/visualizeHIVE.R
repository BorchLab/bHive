#' Visualize bHIVE/honeycombHIVE Results 
#'
#' This function produces publication-quality visualizations for the results 
#' generated by the \code{bHIVE} or \code{honeycombHIVE} functions. Users can 
#' specify one or more layers to visualize and choose from several plot types:
#'
#' \itemize{
#'   \item \code{"scatter"}: A scatterplot of data points and prototypes. 
#'   When \code{X} has more than two columns and \code{transform} is 
#'   \code{TRUE}, a dimensionality reduction method is applied.
#'   \item \code{"boxplot"}: A boxplot of a selected feature by group with 
#'   prototype values overlaid.
#'   \item \code{"violin"}: A violin plot of a selected feature by group 
#'   with prototype values overlaid.
#'   \item \code{"density"}: Density plots of a selected feature by group 
#'   with prototype markers.
#' }
#'
#' For scatterplots the transformation can be selected from \code{"PCA"}, 
#' \code{"UMAP"}, \code{"tSNE"}, or \code{"none"}. When multiple layers are 
#' visualized, the prototypes and the corresponding grouping information from 
#' each layer are combined and faceted by layer.
#'
#' @param result A list object produced by \code{bHIVE} or \code{honeycombHIVE}. 
#' For multilayer models, each element represents one layer.
#' @param X Optional. A numeric matrix or data frame of the original input features.
#' If provided, data points will be plotted along with the prototypes.
#' @param plot_type Character string specifying the type of plot to generate. 
#' Options are:
#'   \itemize{
#'     \item \code{"scatter"}: A scatterplot of data points and prototypes.
#'     \item \code{"boxplot"}: A boxplot of a selected feature by group with 
#'     prototypes overlaid.
#'     \item \code{"violin"}: A violin plot of a selected feature by group 
#'     with prototypes overlaid.
#'     \item \code{"density"}: Density plots of a selected feature by group 
#'     with prototype markers.
#'   }
#' @param feature Optional. For \code{"boxplot"}, \code{"violin"}, or 
#' \code{"density"} plots, the name or index of the feature
#' in \code{X} to display. If \code{NULL}, the first column is used.
#' @param transform Logical. If \code{TRUE} and the data (or prototypes) 
#' has more than two columns, the specified transformation is applied for 
#' scatterplots.
#' @param transformation_method Character. The method used for dimensionality 
#' reduction. Options are \code{"PCA"}, \code{"UMAP"}, \code{"tSNE"}, or 
#' \code{"none"}.
#' @param title Character. Title for the plot.
#' @param layer Integer vector indicating which layer(s) of the result to visualize.
#'   For bHIVE outputs, default is \code{1}. For multilayer honeycombHIVE 
#'   outputs, specify one or more layer indices.
#' @param task Character. The prediction task for the result: one of
#'  \code{"clustering"}, \code{"classification"},
#'   or \code{"regression"}. This is used to determine how grouping is computed.
#' @param ... Additional arguments passed to pca, tSNE, UMAP, or ggplot functions
#'
#' @return A \code{ggplot} object representing the visualization.
#'
#' @examples
#' data(iris)
#' X <- as.matrix(iris[, 1:4])
#'
#' # Run honeycombHIVE for clustering 
#' res <- honeycombHIVE(X = X, 
#'                     task = "clustering", 
#'                     epsilon = 0.05,
#'                     layers = 3, 
#'                     nAntibodies = 30, 
#'                     beta = 5, 
#'                     maxIter = 10, 
#'                     verbose = FALSE)
#'
#' # Visualize layer 2 as a scatterplot (using membership from layer 2).
#' visualizeHIVE(result = res,
#'               X = iris[, 1:4],
#'               plot_type = "scatter",
#'               title = "Layer 2: Scatterplot",
#'               layer = 2,
#'               task = "clustering")
#'
#' # For classification: assume res[[1]]$predictions holds class labels.
#' visualizeHIVE(result = res,
#'               X = iris[, 1:4],
#'               plot_type = "violin",
#'               feature = "Sepal.Width",
#'               title = "Sepal Width by Group (Layer 1)",
#'               layer = 1,
#'               task = "classification")
#'
#' # For regression: prototype grouping is overridden to a constant.
#' visualizeHIVE(result = res,
#'               X = iris[, 1:4],
#'               plot_type = "density",
#'               feature = "Sepal.Width",
#'               title = "Sepal Width Density (Layer 1)",
#'               layer = 1,
#'               task = "regression")
#'
#' @importFrom viridis scale_color_viridis scale_fill_viridis
#' @importFrom Rtsne Rtsne
#' @importFrom umap umap
#' @import ggplot2
#' @export
visualizeHIVE <- function(result, 
                          X = NULL, 
                          plot_type = c("scatter", "boxplot", "violin", "density"),
                          feature = NULL, 
                          transform = TRUE,
                          transformation_method = c("PCA", "UMAP", "tSNE", "none"),
                          title = "HIVE Results", 
                          layer = 1,
                          task = c("clustering", "classification", "regression"),
                          ...) {
  
  plot_type <- match.arg(plot_type)
  transformation_method <- match.arg(transformation_method)
  task <- match.arg(task)
  
  # If result is multilayer, select the specified layers; otherwise, wrap result in a list.
  if (is.list(result) && all(sapply(result, function(x) !is.null(x$antibodies)))) {
    selectedLayers <- result[layer]
    layer_labels <- paste("Layer", layer)
  } else {
    selectedLayers <- list(result)
    layer_labels <- "Layer 1"
  }
  
  # Build prototype list for each selected layer.
  proto_list <- lapply(seq_along(selectedLayers), function(i) {
    layer_i <- selectedLayers[[i]]
    protos <- as.data.frame(layer_i$antibodies)
    protos$Layer <- layer_labels[i]
    # Compute a grouping for prototypes:
    if (task %in% c("classification", "clustering")) {
      # Use predictions if available, otherwise membership; force as factor.
      if (!is.null(layer_i$predictions)) {
        grp <- as.factor(layer_i$predictions)
      } else if (!is.null(layer_i$membership)) {
        grp <- as.factor(layer_i$membership)
      } else {
        grp <- factor(rep(NA, nrow(protos)))
      }
      protos$Group <- grp
    } else if (task == "regression") {
      # For regression, override grouping to a constant.
      protos$Group <- factor(rep("All", nrow(protos)))
    }
    protos
  })
  proto_all <- do.call(rbind, proto_list)
  
  # Helper function: apply transformation to data matrix 'dat'
  transform_data <- function(dat) {
    if (!is.matrix(dat)) dat <- as.matrix(dat)
    if (ncol(dat) < 2) stop("Data must have at least two columns for 2D visualization.")
    if (transformation_method == "PCA") {
      pr <- prcomp(dat, scale. = TRUE, ...)
      return(pr$x[, 1:2, drop = FALSE])
    } else if (transformation_method == "UMAP") {
      umap_res <- umap::umap(dat, ...)
      return(umap_res$layout[, 1:2, drop = FALSE])
    } else if (transformation_method == "tSNE") {
      tsne_res <- Rtsne::Rtsne(dat, ...)
      return(tsne_res$Y[, 1:2, drop = FALSE])
    } else {  # "none"
      return(dat[, 1:2, drop = FALSE])
    }
  }
  
  # Scatter plot branch
  if (!is.null(X) && plot_type == "scatter") {
    data_list <- lapply(seq_along(selectedLayers), function(i) {
      layer_i <- selectedLayers[[i]]
      if (task %in% c("classification", "clustering")) {
        if (!is.null(layer_i$predictions)) {
          grp <- as.factor(layer_i$predictions)
        } else if (!is.null(layer_i$membership)) {
          grp <- as.factor(layer_i$membership)
        } else {
          grp <- factor(rep(NA, nrow(X)))
        }
      } else if (task == "regression") {
        # For regression scatter plot, use a constant group.
        grp <- factor(rep("All", nrow(X)))
      }
      if (transform && ncol(X) > 2 && transformation_method != "none") {
        X_trans <- transform_data(X)
      } else {
        X_trans <- as.matrix(X)[, 1:2, drop = FALSE]
      }
      data.frame(PC1 = X_trans[, 1],
                 PC2 = X_trans[, 2],
                 Group = grp,
                 Layer = layer_labels[i])
    })
    df_points <- do.call(rbind, data_list)
    
    # Transform prototype features.
    feat_cols <- 1:(ncol(proto_all) - 2)  # exclude Layer and Group columns
    if (transform && length(feat_cols) > 2 && transformation_method != "none") {
      proto_coords <- transform_data(as.matrix(proto_all[, feat_cols, drop = FALSE]))
    } else {
      proto_coords <- as.matrix(proto_all)[, 1:2, drop = FALSE]
    }
    df_protos <- data.frame(PC1 = proto_coords[, 1],
                            PC2 = proto_coords[, 2],
                            Group = proto_all$Group,
                            Layer = proto_all$Layer)
    
    p <- ggplot() +
      geom_point(data = df_points, 
                 aes(x = PC1, y = PC2, color = Group),
                 alpha = 0.6, size = 2) +
      geom_point(data = df_protos, 
                 aes(x = PC1, y = PC2),
                 color = "black", size = 4) +
      labs(title = title, x = "Component 1", y = "Component 2")
    
    if (task == "regression") {
      p <- p + scale_color_gradient(low = "blue", high = "red")
    } else {
      p <- p + scale_color_viridis(discrete = TRUE)
    }
    if (length(unique(df_protos$Layer)) > 1)
      p <- p + facet_wrap(~Layer)
    p <- p + theme_minimal()
    return(p)
    
    # Boxplot, violin, and density branch
  } else if (plot_type %in% c("boxplot", "violin", "density")) {
    if (is.null(X))
      stop("For boxplot, violin, or density visualization, X must be provided.")
    # Determine feature to plot.
    if (is.null(feature)) {
      feature <- colnames(X)[1]
      if (is.null(feature)) feature <- 1
    }
    if (is.numeric(feature)) {
      feature_name <- colnames(X)[feature]
      if (is.null(feature_name)) feature_name <- paste("Feature", feature)
      feature_values <- X[, feature]
    } else {
      feature_name <- feature
      feature_values <- X[[feature]]
    }
    # Build grouping data for each selected layer.
    group_list <- lapply(seq_along(selectedLayers), function(i) {
      layer_i <- selectedLayers[[i]]
      if (task %in% c("classification", "clustering")) {
        if (!is.null(layer_i$predictions)) {
          grp <- as.factor(layer_i$predictions)
        } else if (!is.null(layer_i$membership)) {
          grp <- as.factor(layer_i$membership)
        } else {
          grp <- factor(rep(NA, nrow(X)))
        }
      } else if (task == "regression") {
        grp <- factor(rep("All", nrow(X)))
      }
      data.frame(Group = grp, Layer = layer_labels[i])
    })
    df_groups <- do.call(rbind, group_list)
    df_feature <- data.frame(Feature = rep(feature_values, times = length(selectedLayers)),
                             Layer = rep(layer_labels, each = nrow(X)))
    df_feature$Group <- df_groups$Group
    
    # Prepare prototype data for the feature.
    proto_feature <- if (is.numeric(feature)) {
      proto_all[, feature]
    } else {
      proto_all[, feature_name]
    }
    df_proto <- data.frame(Prototype = proto_feature,
                           Group = proto_all$Group,
                           Layer = proto_all$Layer)
    
    if (plot_type == "boxplot") {
      p <- ggplot(df_feature, aes(x = factor(Group), y = Feature, fill = factor(Group))) +
        geom_boxplot(alpha = 0.7) +
        labs(title = paste(title, ":", feature_name),
             x = "Group", y = feature_name) +
        theme_minimal() +
        theme(legend.position = "none") +
        scale_fill_viridis(discrete = TRUE) +
        geom_point(data = df_proto, aes(x = factor(Group), y = Prototype),
                   color = "black", size = 4)
    } else if (plot_type == "violin") {
      p <- ggplot(df_feature, aes(x = factor(Group), y = Feature, fill = factor(Group))) +
        geom_violin(alpha = 0.7) +
        labs(title = paste(title, ":", feature_name),
             x = "Group", y = feature_name) +
        theme_minimal() +
        theme(legend.position = "none") +
        scale_fill_viridis(discrete = TRUE) +
        geom_point(data = df_proto, aes(x = factor(Group), y = Prototype),
                   color = "black", size = 4)
    } else if (plot_type == "density") {
      p <- ggplot(df_feature, aes(x = Feature, fill = factor(Group))) +
        geom_density(alpha = 0.5) +
        labs(title = paste(title, ":", feature_name),
             x = feature_name, y = "Density") +
        theme_minimal() +
        scale_fill_viridis(discrete = TRUE) +
        geom_vline(data = df_proto, aes(xintercept = Prototype, color = Layer),
                   linetype = "dashed", size = 0.5)
    }
    if (length(unique(df_feature$Layer)) > 1)
      p <- p + facet_wrap(~Layer)
    return(p)
    
  } else {
    stop("Invalid plot_type provided.")
  }
}
