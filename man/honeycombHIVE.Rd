% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/honeycombHIVE.R
\name{honeycombHIVE}
\alias{honeycombHIVE}
\title{honeycombHIVE: Multilayered Artificial Immune Network}
\usage{
honeycombHIVE(
  X,
  y = NULL,
  task = c("clustering", "classification", "regression"),
  layers = 3,
  nAntibodies = 20,
  minAntibodies = 5,
  epsilon = 0.05,
  beta = 5,
  maxIter = 10,
  collapseMethod = c("centroid", "medoid", "median", "mode"),
  minClusterSize = NULL,
  distance = "euclidean",
  verbose = TRUE,
  ...
)
}
\arguments{
\item{X}{A numeric matrix or data frame of input features (rows = observations,
columns = features).}

\item{y}{(Optional) A target vector for classification (factor) or regression
(numeric). Ignored if \code{task = "clustering"} or if set to NULL.}

\item{task}{Character, one of \code{"clustering"}, \code{"classification"},
\code{"regression"}.}

\item{layers}{Integer, how many layers (iterations) to run.}

\item{nAntibodies}{Integer, how many antibodies (prototypes) to generate
initially in each layer.}

\item{minAntibodies}{Integer, minimal number of antibodies to keep in each
layer (to avoid going below a certain threshold).}

\item{epsilon}{Numeric, threshold parameter passed to bHIVE.}

\item{beta}{Numeric, hyperparameter controlling selection pressure in bHIVE.}

\item{maxIter}{Integer, maximum iterations for bHIVE in each layer.}

\item{collapseMethod}{How to collapse each cluster: \code{"centroid"},
\code{"medoid"}, \code{"median"}, \code{"mode"}. Default is \code{"centroid"}.}

\item{minClusterSize}{If not NULL, minimum size of clusters. Smaller ones can be
merged or discarded. Default \code{NULL} = no special handling.}

\item{distance}{Distance metric used in the \code{dist} function for medoid
calculation. Default \code{"euclidean"}.}

\item{verbose}{Logical, whether to print progress at each layer.}

\item{...}{Additional parameters passed to the placeholder \code{bHIVE} function.}
}
\value{
A list of length \code{layers}. Each element (layer) includes:
\itemize{
  \item \code{antibodies}: The prototype positions in that layer.
  \item \code{assignments}: The antibody index assigned to each row of that layer's data.
  \item \code{membership}: For each \strong{original} row of \code{X}, which cluster/antibody it belongs to in this layer.
  \item \code{predictions}: For classification/regression, predicted label or numeric value
        for each \strong{row in this layer's data}.
  \item \code{task}: The specified task (clustering, classification, regression).
}
}
\description{
Implements a hierarchical Artificial Immune Network (AI-Net) algorithm with
multiple layers, refining antibody populations iteratively to capture finer
granularity in data patterns. Each layer processes the data based on the
clusters (or assignments) from the previous layer, then collapses them into
prototypes (antibodies) for the next iteration.
}
\details{
For clustering, each cluster is replaced by a single representative
(centroid, medoid, median, or mode). For classification, we also assign a
label to each prototype by majority vote; for regression, we assign an
average target value to each prototype.
}
\examples{
# Example 1: Clustering
data(iris)
X_iris <- iris[, 1:4]
resC <- honeycombHIVE(
  X = X_iris,
  task = "clustering",
  layers = 3,
  nAntibodies = 15,
  beta = 5,
  maxIter = 10
)
# Final cluster membership of original rows:
head(resC[[3]]$membership)


# Example 2: Regression
set.seed(42)
X_reg <- matrix(rnorm(100*4), ncol = 4)
y_reg <- rowSums(X_reg[, 1:2]) + rnorm(100)
resReg <- honeycombHIVE(
  X = X_reg,
  y = y_reg,
  task = "regression",
  layers = 3,
  nAntibodies = 10
)
# Check membership + final predictions:
head(resReg[[3]]$membership)
head(resReg[[3]]$predictions)

}
