% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/honeycombHIVE.R
\name{honeycombHIVE}
\alias{honeycombHIVE}
\title{honeycombHIVE: Multilayer AIS with optional gradient-based fine-tuning}
\usage{
honeycombHIVE(
  X,
  y = NULL,
  task = c("clustering", "classification", "regression"),
  layers = 3,
  nAntibodies = 20,
  minAntibodies = 5,
  epsilon = 0.05,
  beta = 5,
  maxIter = 10,
  collapseMethod = c("centroid", "medoid", "median", "mode"),
  minClusterSize = NULL,
  distance = "euclidean",
  verbose = TRUE,
  refine = FALSE,
  refineLoss = "mse",
  refineSteps = 5,
  refineLR = 0.01,
  refinePushAway = TRUE,
  refineHuberDelta = 1,
  ...
)
}
\arguments{
\item{X}{A numeric matrix or data frame of input features (rows = observations, columns = features).}

\item{y}{Optional target vector (factor for classification, numeric for regression).}

\item{task}{Character, one of "clustering", "classification", or "regression".}

\item{layers}{Integer, how many layers (AIS iterations) to run.}

\item{nAntibodies}{Integer, how many antibodies (prototypes) to generate initially in each layer.}

\item{minAntibodies}{Integer, minimal number of antibodies to keep in each layer.}

\item{epsilon}{Numeric, threshold param for \code{bHIVE} suppression.}

\item{beta}{Numeric, selection pressure param for \code{bHIVE}.}

\item{maxIter}{Integer, maximum iterations for \code{bHIVE} each layer.}

\item{collapseMethod}{One of "centroid","medoid","median","mode".}

\item{minClusterSize}{Minimum cluster size. Smaller clusters can be merged/discarded if not NULL.}

\item{distance}{Distance metric for medoid calculation, e.g. "euclidean".}

\item{verbose}{Logical, if TRUE prints progress at each layer.}

\item{refine}{Logical, if TRUE apply gradient-based refinement via \code{refineB()} to each layer's prototypes.}

\item{refineLoss}{Character specifying the loss for \code{refineB()} (e.g. "mse", "mae", etc.).}

\item{refineSteps}{Integer, # of gradient steps in \code{refineB()}.}

\item{refineLR}{Numeric, learning rate for gradient updates.}

\item{refinePushAway}{Logical, if TRUE and classification, push prototypes away from differently labeled points.}

\item{refineHuberDelta}{Numeric, delta param if using the "huber" loss.}

\item{...}{Additional arguments passed to \code{bHIVE}.}
}
\value{
A list of length \code{layers}. Each element (layer) includes:
  \itemize{
    \item \code{antibodies}: The prototypes in that layer.
    \item \code{assignments}: Antibody index (in that layer) for each row of \code{current_X}.
    \item \code{membership}: For each \strong{original} row in \code{X}, which cluster/antibody it belongs to in this layer.
    \item \code{predictions}: If classification/regression, predicted label or numeric value for each original row in \code{X}.
    \item \code{task}: The specified task.
  }
}
\description{
honeycombHIVE: Multilayer AIS with optional gradient-based fine-tuning
}
\examples{
# Example 1: Clustering
data(iris)
X_iris <- iris[, 1:4]
resC <- honeycombHIVE(
  X = X_iris,
  task = "clustering",
  layers = 3,
  nAntibodies = 15,
  beta = 5,
  maxIter = 10
)
# Final cluster membership of original rows:
head(resC[[3]]$membership)

# Example 2: Regression
set.seed(42)
X_reg <- matrix(rnorm(100*4), ncol = 4)
y_reg <- rowSums(X_reg[, 1:2]) + rnorm(100)
resReg <- honeycombHIVE(
  X = X_reg,
  y = y_reg,
  task = "regression",
  layers = 3,
  nAntibodies = 10
)
# Compare final predictions to original y:
cor(resReg[[3]]$predictions, y_reg)

}
